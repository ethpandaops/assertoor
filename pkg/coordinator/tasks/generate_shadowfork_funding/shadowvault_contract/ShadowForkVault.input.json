{
    "language": "Solidity",
    "sources": {
        "contracts/ShadowForkVault.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./BeaconChainProofs.sol\";\n\ncontract ShadowForkVault {\n    uint256 private originGenesisTime;\n    bytes32[] private zeroHashes;\n    mapping(address => uint256) private depositBalance;\n\n\n    constructor(uint256 genesisTime) {\n        originGenesisTime = genesisTime;\n\n        zeroHashes = new bytes32[](33);\n        for(uint256 i = 0; i < 32; i++) {\n            bytes32 zeroHash = zeroHashes[i];\n            zeroHashes[i+1] = sha256(abi.encodePacked(zeroHash, zeroHash));\n        }\n    }\n\n    function getGenesisTime() public view returns (uint256) {\n        return originGenesisTime;\n    }\n\n    function balanceof(address addr) public view returns (uint256) {\n        return depositBalance[addr];\n    }\n\n    function getBeaconRootBySlot(uint256 slot) public view returns (bytes32) {\n        uint256 slotTime = (slot * BeaconChainProofs.SECONDS_PER_SLOT) + originGenesisTime;\n        return getBeaconRoot(slotTime);\n    }\n\n    function getBeaconRoot(uint256 time) public view returns (bytes32) {\n        bytes32 result;\n        (bool isSuccess, bytes memory response) = address(0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02).staticcall(abi.encodePacked(time + BeaconChainProofs.SECONDS_PER_SLOT));\n        if(isSuccess) {\n            assembly {\n                result := mload(add(response, 32))\n            }\n        }\n        return result;\n    }\n\n    // helper function to generate proofs\n    // use fieldIndex = 0 for slot number proofs\n    function generateHeaderProof(\n        uint256 slotNumber,\n        uint256 proposerIndex,\n        bytes32 parentRoot,\n        bytes32 stateRoot,\n        bytes32 bodyRoot,\n        uint256 fieldIndex\n    ) public view returns (bytes memory) {\n        (, bytes memory proof) = BeaconChainProofs.generateBlockRootProof(\n            zeroHashes,\n            slotNumber,\n            proposerIndex,\n            parentRoot,\n            stateRoot,\n            bodyRoot,\n            fieldIndex\n        );\n        return proof;\n    }\n\n    receive() external payable {\n        depositBalance[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(amount > 0, \"amount must be greater than 0\");\n        require(depositBalance[msg.sender] >= amount, \"amount exceeds balance\");\n\n        depositBalance[msg.sender] -= amount;\n\n        (bool sent, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(sent, \"failed to send ether\");\n    }\n\n    function shadowWithdraw(\n        uint256 slotTime,\n        uint256 slotNumber,\n        bytes memory proof,\n        address target,\n        uint256 amount\n    ) public {\n        bytes32 blockRoot = getBeaconRoot(slotTime);\n        require(blockRoot != bytes32(0), \"no block root for slot time\");\n\n        bool proofValidity = BeaconChainProofs.verifySlotAgainstBlockRoot(blockRoot, slotNumber, proof);\n        require(proofValidity, \"block root verification failed\");\n\n        uint256 currentGenesisTime = slotTime - (slotNumber * BeaconChainProofs.SECONDS_PER_SLOT);\n        require(currentGenesisTime > originGenesisTime, \"not a shadow fork\");\n\n        require(address(this).balance >= amount, \"amount exceeds balance\");\n        if (amount == 0) {\n            amount = address(this).balance;\n        }\n\n        (bool sent, ) = payable(target).call{value: amount}(\"\");\n        require(sent, \"failed to send ether\");\n    }\n}"
        },
        "contracts/BeaconChainProofs.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Merkle.sol\";\n\n//Utility library for parsing and PHASE0 beacon chain block headers\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\nlibrary BeaconChainProofs {\n    // constants are the number of fields and the heights of the different merkle trees used in merkleizing beacon chain containers\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_COUNT = 5;\n\n    // in beacon block header https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\n    uint256 internal constant SLOT_INDEX = 0;\n\n    /// @notice The number of seconds in a slot in the beacon chain\n    uint64 internal constant SECONDS_PER_SLOT = 12;\n\n    /**\n     * @notice This function verifies the slot number against the block root.\n     * @param slotNumber is the beacon chain slot number to be proven against.\n     * @param proof is the provided merkle proof\n     * @param blockRoot is hashtree root of the latest block header in the beacon state\n     */\n    function verifySlotAgainstBlockRoot(\n        bytes32 blockRoot,\n        uint256 slotNumber,\n        bytes memory proof\n    ) internal view returns (bool) {\n        if (proof.length != 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT)) {\n            return false;\n        }\n\n        return Merkle.verifyInclusionSha256({\n            proof: proof,\n            root: blockRoot,\n            leaf: bytes32(reverse(slotNumber)),\n            index: SLOT_INDEX\n        });\n    }\n\n    function generateBlockRootProof(\n        bytes32[] storage zeroHashes,\n        uint256 slotNumber,\n        uint256 proposerIndex,\n        bytes32 parentRoot,\n        bytes32 stateRoot,\n        bytes32 bodyRoot,\n        uint256 fieldIdx\n    ) internal view returns (bytes32, bytes memory) {\n        bytes32[] memory headerFieldRoots = new bytes32[](BEACON_BLOCK_HEADER_FIELD_COUNT);\n\n        headerFieldRoots[0] = bytes32(reverse(slotNumber));\n        headerFieldRoots[1] = bytes32(reverse(proposerIndex));\n        headerFieldRoots[2] = parentRoot;\n        headerFieldRoots[3] = stateRoot;\n        headerFieldRoots[4] = bodyRoot;\n\n        bytes32[][] memory tree = buildHashTree(zeroHashes, headerFieldRoots, BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT);\n\n        bytes memory proof = buildProofFromTree(zeroHashes, tree, BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT, fieldIdx);\n        bytes32 root = buildRootFromTree(tree);\n\n        return (root, proof);\n    }\n\n    function buildHashTree(\n        bytes32[] storage zeroHashes,\n        bytes32[] memory values,\n        uint256 layers\n    ) internal view returns (bytes32[][] memory) {\n        bytes32[][] memory tree = new bytes32[][](layers + 1);\n        tree[0] = values;\n\n        for(uint256 l = 0; l < layers; l++) {\n            uint256 layerSize = tree[l].length;\n            uint256 paddedLayerSize;\n            if (layerSize % 2 == 1) {\n                paddedLayerSize = layerSize + 1;\n            } else {\n                paddedLayerSize = layerSize;\n            }\n\n            uint256 nextLevelSize = paddedLayerSize / 2;\n            bytes32[] memory nextValues = new bytes32[](nextLevelSize);\n\n            for (uint256 i = 0; i < paddedLayerSize; i += 2) {\n                bytes32 leftHash = tree[l][i];\n                bytes32 rightHash;\n                \n                if(i+1 >= layerSize) {\n                    rightHash = zeroHashes[l];\n                } else {\n                    rightHash = tree[l][i+1];\n                }\n\n                nextValues[i/2] = sha256(abi.encodePacked(leftHash, rightHash));\n            }\n\n            tree[l+1] = nextValues;\n        }\n\n        return tree;\n    }\n\n    function buildProofFromTree(\n        bytes32[] memory zeroHashes,\n        bytes32[][] memory tree,\n        uint256 layers,\n        uint256 index\n    ) internal pure returns (bytes memory) {\n        bytes32[] memory proof = new bytes32[](layers);\n        for(uint256 l = 0; l < layers; l++) {\n\n            uint256 layerIndex = (index / (2**l))^1;\n            if(layerIndex < tree[l].length) {\n                proof[l] = tree[l][layerIndex];\n            } else {\n                proof[l] = zeroHashes[l];\n            }\n        }\n\n        bytes memory result = abi.encodePacked(proof[0]);\n        for(uint256 l = 1; l < layers; l++) {\n            result = bytes.concat(result, abi.encodePacked(proof[l]));\n        }\n        \n        return result;\n    }\n\n    function buildRootFromTree(\n        bytes32[][] memory tree\n    ) internal pure returns (bytes32) {\n        uint256 treeSize = tree.length;\n        return tree[treeSize-1][0];\n    }\n\n    function reverse(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n}"
        },
        "contracts/Merkle.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     *\n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(\n        bytes memory proof,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bytes32) {\n        require(\n            proof.length != 0 && proof.length % 32 == 0,\n            \"Merkle.processInclusionProofKeccak: proof length should be a non-zero multiple of 32\"\n        );\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            if (index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(\n        bytes memory proof,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bytes32) {\n        require(\n            proof.length != 0 && proof.length % 32 == 0,\n            \"Merkle.processInclusionProofSha256: proof length should be a non-zero multiple of 32\"\n        );\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            if (index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {\n                        revert(0, 0)\n                    }\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {\n                        revert(0, 0)\n                    }\n                    index := div(index, 2)\n                }\n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n     @return The computed Merkle root of the tree.\n     @dev A pre-condition to this function is that leaves.length is a power of two.  If not, the function will merkleize the inputs incorrectly.\n     */\n    function merkleizeSha256(bytes32[] memory leaves) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint256 i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2 * i], leaves[2 * i + 1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint256 i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2 * i], layer[2 * i + 1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 2000
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        },
        "remappings": []
    }
}